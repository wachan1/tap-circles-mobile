<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Circle Tapper</title>
<style>
  :root {
    --bg0: #0b0f1a;
    --bg1: #121a2a;
    --text: #ffffff;
    --accent: #ffd166;
    --good: #3ad29f;
    --bad: #ff5964;
    --overlay: rgba(0,0,0,0.6);
    --panel: rgba(20,27,45,0.9);
  }

  html, body {
    margin: 0; padding: 0; height: 100%; background: radial-gradient(120% 120% at 50% 0%, var(--bg1), var(--bg0));
    color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
    touch-action: none; overscroll-behavior: none;
  }

  #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; }

  /* Top bar */
  .topbar {
    display: flex; justify-content: space-between; align-items: center;
    padding: env(safe-area-inset-top) 16px 8px 16px;
    font-weight: 700; letter-spacing: 0.3px; user-select: none; -webkit-user-select: none;
    background: linear-gradient(to bottom, rgba(0,0,0,0.25), rgba(0,0,0,0));
  }
  .score { font-size: 20px; }
  .high { font-size: 16px; color: var(--accent); }

  /* Canvas play area */
  #gameCanvas { width: 100%; height: 100%; display: block; touch-action: none; }

  /* Bottom bar */
  .bottombar {
    display: flex; justify-content: space-between; align-items: center; gap: 12px;
    padding: 8px 16px calc(8px + env(safe-area-inset-bottom)) 16px;
    background: linear-gradient(to top, rgba(0,0,0,0.25), rgba(0,0,0,0));
  }
  .btn {
    flex: 1 1 0; padding: 12px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.06); color: var(--text); font-weight: 700; font-size: 16px;
    text-align: center; -webkit-tap-highlight-color: transparent;
  }
  .btn:active { transform: scale(0.98); }

  /* Overlays */
  .overlay {
    position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
    background: var(--overlay); backdrop-filter: blur(2px);
    padding: 24px; z-index: 10;
  }
  .overlay.show { display: flex; }

  .panel {
    width: min(520px, 90vw); border-radius: 16px; background: var(--panel); padding: 20px;
    border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  }
  .panel h1 { margin: 0 0 10px; font-size: 28px; }
  .panel h2 { margin: 0 0 16px; font-size: 22px; }
  .panel p { margin: 0 0 12px; opacity: 0.9; line-height: 1.4; }
  .panel .actions { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 16px; }
  .panel .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

  .btn.primary { background: linear-gradient(180deg, #5cd5ff, #2687ff); border: none; }
  .btn.good    { background: linear-gradient(180deg, #56f1b2, #2bbf86); border: none; }
  .btn.warn    { background: linear-gradient(180deg, #ff8d8d, #ff4f4f); border: none; }

  /* Floating points */
  .float-layer { position: fixed; inset: 0; pointer-events: none; z-index: 6; }
  .float { position: absolute; font-weight: 800; text-shadow: 0 2px 10px rgba(0,0,0,0.4); }

  /* Red damage vignette */
  .damage {
    position: fixed; inset: 0; pointer-events: none; z-index: 9; opacity: 0;
    background: radial-gradient(60% 60% at 50% 50%, rgba(255,0,0,0.0), rgba(255,0,0,0.35) 80%);
  }
  .damage.flash { animation: flash 300ms ease-out; }
  @keyframes flash {
    0% { opacity: 0.0; }
    40% { opacity: 1.0; }
    100% { opacity: 0.0; }
  }
</style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="score">Score: <span id="scoreText">1000</span></div>
    <div class="high">High: <span id="highText">0</span></div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div class="bottombar">
    <button class="btn" id="pauseBtn">‚è∏ Pause</button>
    <button class="btn" id="restartBtn">üîÑ Restart</button>
  </div>
</div>

<!-- Start Screen -->
<div class="overlay show" id="startOverlay" aria-modal="true">
  <div class="panel">
    <h1>Circle Tapper</h1>
    <p>Tap circles early for points. After 80% size they turn red and cost you points. Score ticks down 100/sec ‚Äî survive and score big.</p>
    <div class="actions">
      <button class="btn primary" id="startBtn">Start</button>
      <button class="btn" id="muteToggleStart">üîä Mute/Unmute</button>
    </div>
  </div>
</div>

<!-- Pause Menu -->
<div class="overlay" id="pauseOverlay" aria-modal="true">
  <div class="panel">
    <h2>Paused</h2>
    <div class="actions">
      <button class="btn good" id="resumeBtn">‚ñ∂ Resume</button>
      <div class="row">
        <button class="btn" id="muteToggle">üîä Mute/Unmute</button>
        <button class="btn" id="restartFromPauseBtn">üîÑ Restart</button>
      </div>
      <button class="btn warn" id="backToStartBtn">‚Ü© Back to Start</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div class="overlay" id="gameOverOverlay" aria-modal="true">
  <div class="panel">
    <h2>Game Over</h2>
    <p>Your Score: <strong id="finalScore">0</strong></p>
    <p id="newHigh" style="display:none;">üèÜ NEW HIGH SCORE!</p>
    <div class="actions">
      <button class="btn good" id="playAgainBtn">‚ñ∂ Play Again</button>
      <button class="btn" id="backToStart2Btn">‚Ü© Back to Start</button>
    </div>
  </div>
</div>

<!-- Red vignette & floating points layer -->
<div class="damage" id="damageFlash"></div>
<div class="float-layer" id="floatLayer"></div>

<script>
(function() {
  // ======== Config / Constants ========
  const START_SCORE = 1000;
  const SCORE_DRAIN_PER_SEC = 100;

  // Growth speeds (px/sec)
  const MIN_GROWTH = 20;
  const MAX_GROWTH = 120;

  const MAX_CIRCLES_CAP = 6;

  // Colors by ratio
  function colorForRatio(ratio) {
    if (ratio >= 1) return '#000000';
    if (ratio >= 0.8) return '#ff3b30'; // red
    if (ratio >= 0.4) return '#3a86ff'; // blue
    return '#ffffff';                   // white
  }

  // ======== State ========
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  const scoreEl = document.getElementById('scoreText');
  const highEl  = document.getElementById('highText');

  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  const damageFlash = document.getElementById('damageFlash');
  const floatLayer = document.getElementById('floatLayer');

  const startBtn = document.getElementById('startBtn');
  const muteToggleStart = document.getElementById('muteToggleStart');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const muteToggle = document.getElementById('muteToggle');
  const restartFromPauseBtn = document.getElementById('restartFromPauseBtn');
  const backToStartBtn = document.getElementById('backToStartBtn');
  const backToStart2Btn = document.getElementById('backToStart2Btn');
  const playAgainBtn = document.getElementById('playAgainBtn');

  const finalScoreEl = document.getElementById('finalScore');
  const newHighEl = document.getElementById('newHigh');

  let width = 0, height = 0, dpr = Math.max(1, window.devicePixelRatio || 1);

  const storage = {
    get high() { return Number(localStorage.getItem('ct_high') || 0); },
    set high(v) { localStorage.setItem('ct_high', String(v)); },
    get mute() { return localStorage.getItem('ct_mute') === '1'; },
    set mute(v) { localStorage.setItem('ct_mute', v ? '1' : '0'); }
  };

  let audio = {
    ctx: null,
    enabled: false,
    init() {
      if (this.ctx) return;
      try {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = !storage.mute;
      } catch (_) {
        this.ctx = null;
        this.enabled = false;
      }
    },
    buzz(duration = 80, freq = 140) {
      if (!this.ctx || !this.enabled) return;
      const t = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = 'square'; o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.001, t);
      g.gain.exponentialRampToValueAtTime(0.2, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, t + duration/1000);
      o.connect(g).connect(this.ctx.destination);
      o.start(t); o.stop(t + duration/1000);
    },
    pop(duration = 30, freq = 320) {
      if (!this.ctx || !this.enabled) return;
      const t = this.ctx.currentTime;
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = 'sine'; o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.25, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + duration/1000);
      o.connect(g).connect(this.ctx.destination);
      o.start(t); o.stop(t + duration/1000);
    }
  };

  function vibrate(ms=40) {
    if (navigator.vibrate) navigator.vibrate(ms);
  }

  // UI init
  highEl.textContent = storage.high;

  function resize() {
    const rect = document.body.getBoundingClientRect();
    width = Math.floor(rect.width * dpr);
    height = Math.floor(rect.height * dpr);
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Prevent page scroll/zoom gestures interfering
  window.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

  // ======== Game Model ========
  const STATE = { START: 'start', RUN: 'run', PAUSE: 'pause', OVER: 'over' };
  let gameState = STATE.START;

  let score = START_SCORE;
  let high = storage.high;
  let elapsed = 0; // ms since run start (paused time excluded)
  let lastFrameTime = 0;
  let spawnAccumulator = 0;

  const circles = [];
  const floatTexts = [];

  function spawnInterval(t) {
    // t in ms
    return Math.max(0.4, 1.5 * Math.exp(-0.0015 * t/1)) * 1000; // return ms
  }
  function globalGrowthSpeed(t) {
    const spd = MIN_GROWTH + (100 * (t / 60000));
    return Math.min(MAX_GROWTH, spd);
  }
  function maxCircles(t) {
    const v = 1 + Math.log(1 + (t / 10000)) / Math.log(1.5);
    return Math.min(MAX_CIRCLES_CAP, Math.floor(v));
  }

  function newCircle(t) {
    const rMax = Math.max(28, Math.min(window.innerWidth, window.innerHeight) * 0.18); // max radius in CSS px
    // Slight per-circle variance around global speed (¬±12%)
    const base = globalGrowthSpeed(t);
    const speed = base * (0.88 + Math.random() * 0.24);

    // Keep circles away from UI bars (approx 64px top/bottom)
    const margin = rMax + 64;
    const x = margin + Math.random() * (window.innerWidth - margin * 2);
    const y = margin + Math.random() * (window.innerHeight - margin * 2);

    return {
      id: Math.random().toString(36).slice(2),
      x, y, r: 0, rMax, speed, born: performance.now()
    };
  }

  function baseRewardForCircle(c) {
    // Guarantee at least +100 at spawn for slowest growth; scale with speed
    // MIN_GROWTH -> 100, MAX_GROWTH -> 100 * (MAX/MIN) = 600
    return 100 * (c.speed / MIN_GROWTH);
  }

  function rewardForTap(c) {
    const ratio = Math.min(1, c.r / c.rMax);
    const base = baseRewardForCircle(c);
    if (ratio < 0.8) {
      // Linear decay from base -> 0 across [0, 0.8]
      const k = 1 - (ratio / 0.8);
      return Math.round(base * k);
    } else {
      // Penalty grows from 0 -> -base across (0.8, 1]
      const k = (ratio - 0.8) / 0.2; // 0..1
      return -Math.round(base * k);
    }
  }

  function autoPenalty(c) {
    // When circle hits max size and disappears
    return -Math.round(baseRewardForCircle(c));
  }

  function addFloatText(x, y, text, good) {
    floatTexts.push({
      x, y, text, good, t: 0, ttl: 700 // ms
    });
  }

  function flashDamage() {
    damageFlash.classList.remove('flash');
    // force reflow to restart animation
    void damageFlash.offsetWidth;
    damageFlash.classList.add('flash');
  }

  // ======== Input ========
  function getPointerPos(evt) {
    if (evt.touches && evt.touches[0]) {
      return { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
    }
    return { x: evt.clientX, y: evt.clientY };
  }

  function handleTap(x, y) {
    if (gameState !== STATE.RUN) return;
    // Find topmost circle whose center distance <= radius
    // We'll test closest first
    let best = null, bestDist = Infinity, bestIdx = -1;
    for (let i = 0; i < circles.length; i++) {
      const c = circles[i];
      const dx = x - c.x, dy = y - c.y;
      const dist = Math.hypot(dx, dy);
      if (dist <= c.r && dist < bestDist) { best = c; bestDist = dist; bestIdx = i; }
    }
    if (!best) return;

    const delta = rewardForTap(best);
    score = Math.max(0, Math.round(score + delta));
    addFloatText(x, y - 8, (delta >= 0 ? '+' : '') + delta, delta >= 0);

    if (delta < 0) {
      vibrate(40);
      audio.buzz(90, 160);
      flashDamage();
    } else {
      audio.pop(35, 340);
    }

    // Remove the tapped circle
    circles.splice(bestIdx, 1);
    // Update high score live
    if (score > high) {
      high = score; storage.high = high; highEl.textContent = high;
    }
  }

  canvas.addEventListener('touchstart', (e) => {
    const p = getPointerPos(e);
    handleTap(p.x, p.y);
  }, { passive: true });
  canvas.addEventListener('mousedown', (e) => {
    const p = getPointerPos(e);
    handleTap(p.x, p.y);
  });

  // ======== Loop ========
  function step(ts) {
    if (!lastFrameTime) lastFrameTime = ts;
    const dt = Math.max(0, Math.min(50, ts - lastFrameTime)); // clamp to 50ms/frame
    lastFrameTime = ts;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameState === STATE.RUN) {
      elapsed += dt;
      // Score drain
      score = Math.max(0, score - (SCORE_DRAIN_PER_SEC * dt / 1000));
      score = Math.round(score);
      scoreEl.textContent = score;
      if (score > high) { high = score; storage.high = high; highEl.textContent = high; }

      // Spawning
      spawnAccumulator += dt;
      const interval = spawnInterval(elapsed);
      const cap = maxCircles(elapsed);
      while (spawnAccumulator >= interval && circles.length < cap) {
        spawnAccumulator -= interval;
        circles.push(newCircle(elapsed));
      }

      // Update circles
      for (let i = circles.length - 1; i >= 0; i--) {
        const c = circles[i];
        c.r += c.speed * (dt / 1000);
        if (c.r >= c.rMax) {
          // auto penalty
          const pen = autoPenalty(c);
          score = Math.max(0, Math.round(score + pen));
          addFloatText(c.x, c.y, String(pen), false);
          vibrate(50);
          audio.buzz(120, 150);
          flashDamage();
          circles.splice(i, 1);
        }
      }
      if (score <= 0) endGame();
    }

    // Render circles
    for (const c of circles) {
      const ratio = Math.min(1, c.r / c.rMax);
      const col = colorForRatio(ratio);
      // soft glow
      ctx.beginPath();
      ctx.fillStyle = col;
      ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
      ctx.fill();

      // subtle outline
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.stroke();
    }

    // Floating texts
    for (let i = floatTexts.length - 1; i >= 0; i--) {
      const f = floatTexts[i];
      f.t += dt;
      const a = 1 - (f.t / f.ttl);
      if (a <= 0) { floatTexts.splice(i, 1); continue; }
      const y = f.y - (f.t / f.ttl) * 40;
      drawFloatingText(f.text, f.x, y, f.good ? 'var(--good)' : 'var(--bad)', a);
    }

    requestAnimationFrame(step);
  }

  function drawFloatingText(text, x, y, colorVar, alpha) {
    // Use DOM for crisp text positioning above canvas
    let el = document.createElement('div');
    el.className = 'float';
    el.textContent = text;
    el.style.left = (x - 10) + 'px';
    el.style.top = (y - 10) + 'px';
    el.style.color = getComputedStyle(document.documentElement).getPropertyValue(colorVar.replace('var','')).trim() || (colorVar.includes('good') ? '#3ad29f' : '#ff5964');
    el.style.opacity = alpha;
    floatLayer.appendChild(el);
    // Schedule removal right away after browser paints (we re-create each frame)
    queueMicrotask(() => { if (el.parentNode) el.parentNode.removeChild(el); });
  }

  function startGame() {
    audio.init(); // unlock audio from user gesture
    score = START_SCORE;
    scoreEl.textContent = score;
    elapsed = 0;
    spawnAccumulator = 0;
    lastFrameTime = 0;
    circles.length = 0;
    floatTexts.length = 0;
    gameState = STATE.RUN;
    startOverlay.classList.remove('show');
    pauseOverlay.classList.remove('show');
    gameOverOverlay.classList.remove('show');
  }

  function pauseGame() {
    if (gameState !== STATE.RUN) return;
    gameState = STATE.PAUSE;
    pauseOverlay.classList.add('show');
  }

  function resumeGame() {
    if (gameState !== STATE.PAUSE) return;
    gameState = STATE.RUN;
    lastFrameTime = 0; // avoid time jump
    pauseOverlay.classList.remove('show');
  }

  function restartGame() {
    startGame();
  }

  function endGame() {
    if (gameState === STATE.OVER) return;
    gameState = STATE.OVER;
    finalScoreEl.textContent = score;
    const beatHigh = score >= storage.high;
    if (beatHigh) { storage.high = score; high = score; }
    highEl.textContent = storage.high;
    newHighEl.style.display = beatHigh ? 'block' : 'none';
    gameOverOverlay.classList.add('show');
  }

  function backToStart() {
    gameState = STATE.START;
    circles.length = 0;
    floatTexts.length = 0;
    gameOverOverlay.classList.remove('show');
    pauseOverlay.classList.remove('show');
    startOverlay.classList.add('show');
  }

  // ======== Buttons ========
  startBtn.addEventListener('click', startGame);
  muteToggleStart.addEventListener('click', () => {
    audio.init(); storage.mute = !storage.mute; audio.enabled = !storage.mute;
  });
  pauseBtn.addEventListener('click', pauseGame);
  restartBtn.addEventListener('click', restartGame);
  resumeBtn.addEventListener('click', resumeGame);
  muteToggle.addEventListener('click', () => {
    audio.init(); storage.mute = !storage.mute; audio.enabled = !storage.mute;
  });
  restartFromPauseBtn.addEventListener('click', () => { pauseOverlay.classList.remove('show'); restartGame(); });
  backToStartBtn.addEventListener('click', backToStart);
  backToStart2Btn.addEventListener('click', backToStart);
  playAgainBtn.addEventListener('click', () => { gameOverOverlay.classList.remove('show'); restartGame(); });

  // ======== Start loop ========
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
