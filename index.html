<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circle Tap Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      touch-action: manipulation;
    }
    #top-bar {
      position: absolute;
      top: 0;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      font-size: 20px;
      background: rgba(0, 0, 0, 0.4);
    }
    #bottom-bar {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.4);
    }
    button {
      font-size: 18px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: #444;
      color: white;
    }
    #pause-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: white;
      z-index: 10;
      visibility: hidden;
    }
    #pause-overlay button {
      margin-top: 20px;
      font-size: 22px;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="top-bar">
    <div>Score: <span id="score">1000</span></div>
    <div>High: <span id="highscore">0</span></div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="bottom-bar">
    <button id="pauseBtn">Pause</button>
    <button id="restartBtn">Restart</button>
  </div>
  <div id="pause-overlay">
    <div>Game Paused</div>
    <button id="resumeBtn">Resume</button>
  </div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let width, height;
function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

let score = 1000;
let highscore = parseInt(localStorage.getItem("circleGameHighScore")) || 0;
document.getElementById("highscore").textContent = highscore;

let elapsed = 0; // seconds
let lastFrame = performance.now();
let paused = false;
let circles = [];

class Circle {
  constructor() {
    this.x = Math.random() * (width - 60) + 30;
    this.y = Math.random() * (height - 160) + 80;
    this.radius = 10;
    this.maxRadius = 120;
    this.growthRate = 20; // pixels/sec, will scale with difficulty
  }
  update(dt, growthScale) {
    this.radius += this.growthRate * growthScale * dt;
  }
  draw() {
    let color;
    if (this.radius < 40) color = "white";
    else if (this.radius < 70) color = "blue";
    else if (this.radius < 100) color = "red";
    else color = "black";
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.fill();
  }
  contains(px, py) {
    return Math.hypot(this.x - px, this.y - py) < this.radius;
  }
}

canvas.addEventListener("touchstart", (e) => {
  const touch = e.touches[0];
  handleTap(touch.clientX, touch.clientY);
});

canvas.addEventListener("mousedown", (e) => {
  handleTap(e.clientX, e.clientY);
});

function handleTap(x, y) {
  for (let i = circles.length - 1; i >= 0; i--) {
    if (circles[i].contains(x, y)) {
      let c = circles[i];
      let points = Math.max(10, 150 - c.radius); // smaller circle = more points
      score += Math.floor(points);
      circles.splice(i, 1);
      return;
    }
  }
}

function spawnCircle() {
  if (circles.length < maxCircles()) {
    circles.push(new Circle());
  }
}

function spawnInterval() {
  // decreases as elapsed increases (down to ~0.6s)
  return Math.max(0.6, 2.0 - 0.05 * Math.log(elapsed+1));
}

function growthScale() {
  // circle grows faster over time
  return 1 + 0.02 * Math.log(elapsed+1);
}

function maxCircles() {
  // increases gradually with time, capped at 6
  return Math.min(6, 2 + Math.floor(elapsed/15));
}

let spawnTimer = 0;

function update(dt) {
  elapsed += dt;
  // subtract score for survival timer
  score -= 100 * dt;
  if (score <= 0) {
    score = 0;
    gameOver();
    return;
  }
  spawnTimer += dt;
  if (spawnTimer >= spawnInterval()) {
    spawnCircle();
    spawnTimer = 0;
  }
  for (let i = circles.length-1; i >= 0; i--) {
    circles[i].update(dt, growthScale());
    if (circles[i].radius > circles[i].maxRadius) {
      score -= 200; // penalty
      circles.splice(i, 1);
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, width, height);
  circles.forEach(c => c.draw());
}

function loop(timestamp) {
  if (!paused) {
    let dt = (timestamp - lastFrame) / 1000;
    lastFrame = timestamp;
    update(dt);
    draw();
    document.getElementById("score").textContent = Math.floor(score);
    if (score > highscore) {
      highscore = Math.floor(score);
      localStorage.setItem("circleGameHighScore", highscore);
      document.getElementById("highscore").textContent = highscore;
    }
  } else {
    lastFrame = timestamp; // prevent time jump
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function gameOver() {
  paused = true;
  document.getElementById("pause-overlay").style.visibility = "visible";
  document.getElementById("pause-overlay").firstChild.textContent = "Game Over";
}

document.getElementById("pauseBtn").addEventListener("click", () => {
  paused = true;
  document.getElementById("pause-overlay").style.visibility = "visible";
  document.getElementById("pause-overlay").firstChild.textContent = "Game Paused";
});
document.getElementById("resumeBtn").addEventListener("click", () => {
  paused = false;
  document.getElementById("pause-overlay").style.visibility = "hidden";
});
document.getElementById("restartBtn").addEventListener("click", restart);

function restart() {
  score = 1000;
  elapsed = 0;
  circles = [];
  spawnTimer = 0;
  paused = false;
  document.getElementById("pause-overlay").style.visibility = "hidden";
}
</script>
</body>
</html>
