<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Tap the Circles</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0e0f12;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #e6e6e6;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #ui {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      z-index: 10;
      pointer-events: none;
    }
    .pill {
      pointer-events: auto;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 999px;
      padding: 12px 20px;
      backdrop-filter: blur(8px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      font-weight: 700;
      font-size: 18px;
      text-align: center;
      min-width: 140px;
    }
    #controls { display: flex; gap: 10px; }
    button {
      pointer-events: auto;
      border: 0;
      border-radius: 999px;
      padding: 14px 20px;
      font-weight: 700;
      font-size: 18px;
      background: #2b7fff;
      color: white;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(10,80,220,0.45);
    }
    button.secondary {
      background: rgba(255,255,255,0.08);
      color: #e6e6e6;
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: none;
    }
    #canvas {
      position: fixed;
      inset: 0;
      touch-action: none;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .panel {
      pointer-events: auto;
      text-align: center;
      background: rgba(15,16,20,0.86);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 24px 20px;
      width: min(90vw, 420px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.55);
    }
    .title {
      font-size: 26px;
      font-weight: 900;
      margin-bottom: 8px;
    }
    .subtitle {
      opacity: 0.85;
      margin-bottom: 16px;
      font-size: 16px;
      line-height: 1.4;
    }
    .row {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .note { font-size: 14px; opacity: 0.75; margin-top: 12px; }
    .good { color: #7bf69f; font-weight: 800; }
    .bad { color: #ff6a7a; font-weight: 800; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="ui">
    <div class="pill" id="score">Score: 1000</div>
    <div class="pill" id="highscore">Best: 0</div>
    <div id="controls">
      <button id="pauseBtn" class="secondary">Pause</button>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <div id="overlay">
    <div id="startPanel" class="panel">
      <div class="title">Tap the Circles</div>
      <div class="subtitle">
        Tap circles before they grow too large.<br/>
        Start at <b>1000</b>, lose <b>100/sec</b>.<br/>
        Early taps: <span class="good">+200</span>, late taps: <span class="bad">-100</span>, miss: <span class="bad">-200</span>.
      </div>
      <div class="row">
        <button id="startBtn">Start</button>
      </div>
      <div class="note">White → Blue → Red → Black means danger!</div>
    </div>

    <div id="gameOverPanel" class="panel" style="display:none;">
      <div class="title">Game Over</div>
      <div id="finalScore" class="subtitle">Your score: 0</div>
      <div class="row">
        <button id="againBtn">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const startBtn = document.getElementById('startBtn');
    const againBtn = document.getElementById('againBtn');
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const startPanel = document.getElementById('startPanel');
    const gameOverPanel = document.getElementById('gameOverPanel');
    const finalScoreEl = document.getElementById('finalScore');

    let DPR = window.devicePixelRatio || 1;
    let W = 0, H = 0;

    function resize() {
      DPR = window.devicePixelRatio || 1;
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W * DPR;
      canvas.height = H * DPR;
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    let circles = [];
    let nextId = 1;
    let running = false;
    let paused = false;
    let score = 1000;
    let best = Number(localStorage.getItem('tap-best') || '0');
    let last = performance.now();
    let spawnAccumulator = 0;
    let difficultyTime = 0;

    highscoreEl.textContent = 'Best: ' + best;

    function resetGame() {
      circles = [];
      nextId = 1;
      running = true;
      paused = false;
      score = 1000;
      last = performance.now();
      spawnAccumulator = 0;
      difficultyTime = 0;
      startPanel.style.display = 'none';
      gameOverPanel.style.display = 'none';
      pauseBtn.textContent = 'Pause';
      loop();
    }

    function gameOver() {
      running = false;
      best = Math.max(best, Math.floor(score));
      localStorage.setItem('tap-best', best);
      highscoreEl.textContent = 'Best: ' + best;
      finalScoreEl.textContent = 'Your score: ' + Math.floor(score);
      gameOverPanel.style.display = 'block';
    }

    function rand(a, b) { return a + Math.random() * (b - a); }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function spawnCircle() {
      const r0 = rand(12, 18);
      const rMax = rand(80, Math.min(W, H) * 0.35);
      const growth = rand(28, 80);
      const x = rand(rMax+6, W-rMax-6);
      const y = rand(rMax+6, H-rMax-6);
      circles.push({id: nextId++, x, y, r: r0, r0, rMax, growth});
    }

    function colorFor(c) {
      const t = clamp((c.r-c.r0)/(c.rMax-c.r0), 0, 1);
      const c0=[255,255,255],c1=[50,150,255],c2=[255,70,70],c3=[0,0,0];
      let a,b,u;
      if(t<1/3){a=c0;b=c1;u=t*3;}
      else if(t<2/3){a=c1;b=c2;u=(t-1/3)*3;}
      else{a=c2;b=c3;u=(t-2/3)*3;}
      const r=Math.round(a[0]+(b[0]-a[0])*u);
      const g=Math.round(a[1]+(b[1]-a[1])*u);
      const bl=Math.round(a[2]+(b[2]-a[2])*u);
      return `rgb(${r},${g},${bl})`;
    }

    function pointsFor(c) {
      const t = clamp((c.r-c.r0)/(c.rMax-c.r0), 0, 1);
      if(t<=0.6){return Math.round(200*(1-t/0.6));}
      return -Math.round(100*((t-0.6)/0.4));
    }

    const AUTO_PENALTY = 200;
    const particles = [];
    const floaters = [];

    function spawnBurst(x,y,color){
      const n=12;
      for(let i=0;i<n;i++){
        particles.push({x,y,vx:(Math.random()*2-1)*150,vy:(Math.random()*2-1)*150,
          life:0.4+Math.random()*0.3,t:0,color});
      }
    }

    function handlePoint(px,py){
      if(!running||paused)return;
      for(let i=circles.length-1;i>=0;i--){
        const c=circles[i];
        const dx=px-c.x,dy=py-c.y;
        if(dx*dx+dy*dy<=c.r*c.r){
          const pts=pointsFor(c);
          score+=pts;
          circles.splice(i,1);
          spawnBurst(c.x,c.y,colorFor(c));
          floaters.push({x:c.x,y:c.y,t:0,txt:(pts>=0?'+':'')+pts,good:pts>=0});
          if(navigator.vibrate) navigator.vibrate(40);
          return;
        }
      }
    }

    canvas.addEventListener('touchstart',e=>{
      const rect=canvas.getBoundingClientRect();
      const t=e.changedTouches[0];
      handlePoint(t.clientX-rect.left,t.clientY-rect.top);
    },{passive:true});

    canvas.addEventListener('mousedown',e=>{
      const rect=canvas.getBoundingClientRect();
      handlePoint(e.clientX-rect.left,e.clientY-rect.top);
    });

    startBtn.onclick=resetGame;
    againBtn.onclick=resetGame;
    restartBtn.onclick=resetGame;
    pauseBtn.onclick=()=>{
      if(!running)return;
      paused=!paused;
      pauseBtn.textContent=paused?'Resume':'Pause';
      if(!paused){last=performance.now();loop();}
    };

    function loop(){
      if(!running||paused)return;
      const now=performance.now();
      const dt=Math.min(0.05,(now-last)/1000);
      last=now;
      difficultyTime+=dt;
      score-=100*dt;
      if(score<=0){score=0;scoreEl.textContent='Score: 0';render();gameOver();return;}
      scoreEl.textContent='Score: '+Math.floor(score);

      const baseInterval=0.9-Math.min(0.5,difficultyTime/120*0.5);
      spawnAccumulator+=dt;
      while(spawnAccumulator>=baseInterval){
        spawnAccumulator-=baseInterval;
        const cap=2+Math.floor(Math.min(6,difficultyTime/20));
        if(circles.length<cap)spawnCircle();
      }

      for(let i=circles.length-1;i>=0;i--){
        const c=circles[i];
        c.r+=c.growth*dt;
        if(c.r>=c.rMax){
          score-=AUTO_PENALTY;
          floaters.push({x:c.x,y:c.y,t:0,txt:'-'+AUTO_PENALTY,good:false});
          spawnBurst(c.x,c.y,'rgb(255,60,60)');
          circles.splice(i,1);
          if(navigator.vibrate) navigator.vibrate([80,40,80]);
          if(score<=0){score=0;scoreEl.textContent='Score: 0';render();gameOver();return;}
        }
      }

      for(let i=particles.length-1;i>=0;i--){
        const p=particles[i];p.t+=dt;
        if(p.t>=p.life){particles.splice(i,1);continue;}
        p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=260*dt;
      }

      for(let i=floaters.length-1;i>=0;i--){
        const f=floaters[i];f.t+=dt;
        if(f.t>=0.9){floaters.splice(i,1);continue;}
        f.y-=40*dt;
      }

      render();
      requestAnimationFrame(loop);
    }

    function render(){
      ctx.clearRect(0,0,W,H);
      for(const c of circles){
        ctx.beginPath();ctx.arc(c.x,c.y,c.r,0,Math.PI*2);
        ctx.fillStyle=colorFor(c);ctx.fill();
      }
      for(const p of particles){
        const a=1-(p.t/p.life);
        ctx.globalAlpha=a;
        ctx.beginPath();ctx.arc(p.x,p.y,2+2*a,0,Math.PI*2);
        ctx.fillStyle=p.color;ctx.fill();ctx.globalAlpha=1;
      }
      for(const f of floaters){
        const a=1-(f.t/0.9);ctx.globalAlpha=a;
        ctx.font='700 20px -apple-system,BlinkMacSystemFont,Segoe UI';
        ctx.textAlign='center';ctx.textBaseline='middle';
        ctx.fillStyle=f.good?'#7bf69f':'#ff6a7a';
        ctx.fillText(f.txt,f.x,f.y);ctx.globalAlpha=1;
      }
    }

    render();
  </script>
</body>
</html>
