<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Circle Tapper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    :root{
      --bg1:#0b0f16;
      --bg2:#151b26;
      --hudH:56px;
      --ctrlH:64px;
      --accent:#ffd54a; /* high score */
      --good:#33d17a;
      --bad:#ff4d4f;
      --text:#ffffff;
      --muted:#9aa4b2;
      --panel:#0f1420cc;
      --btn:#1f2837;
      --btnText:#e6e9ee;
      --btnHover:#2a3447;
      --shadow:rgba(0,0,0,.35);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1200px 900px at 50% 30%, var(--bg2), var(--bg1));
      overflow:hidden; /* no scrolling */
      user-select:none;
      touch-action:manipulation;
    }

    /* Base (desktop / landscape): 3 columns (Top) */
    #hud{
      position:fixed; top:0; left:0; right:0; height:var(--hudH);
      display:grid;
      grid-template-columns: 1fr auto 1fr; /* score | time | high */
      align-items:center;
      padding:0 14px;
      background:linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,.10));
      backdrop-filter: blur(6px);
      z-index:10;
      gap:12px;
    }
    
    #score, #high, #time{
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    
    #score{ font-weight:800; font-size:20px; letter-spacing:.3px; justify-self:start; min-width: 11ch; text-align:left; }
    #high { font-weight:700; font-size:16px; color:var(--accent); justify-self:end; min-width: 10ch; text-align:right; }
    #time { font-size:14px; color:var(--muted); font-weight:700; text-align:center; }
    
    /* --- Small portrait phones --- */
    @media (max-width: 420px){
      #hud{
        grid-template-columns: 1fr 1fr;             /* 2 columns */
        grid-template-areas:
          "score high"
          "time  time";
        height: calc(var(--hudH) + 14px);           /* a bit taller */
        gap: 6px 10px;
        padding: 4px 10px;
      }
      #score { grid-area: score; min-width:auto; font-size:18px; }
      #high  { grid-area: high;  min-width:auto; font-size:14px; }
      #time  { grid-area: time;  font-size:13px; }
    }
    
    /* --- Ultra small (older iPhones in portrait, tiny viewports) --- */
    @media (max-width: 340px){
      #score{ font-size:16px; }
      #high { font-size:13px; }
      #time { font-size:12px; }
      /* Hide the best-time parenthetical to save space */
      #time .best-part{ display:none; }
    }

    /* Controls (bottom) */
    #controls{
      position:fixed; bottom:0; left:0; right:0; height:var(--ctrlH);
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      background:linear-gradient(to top, rgba(0,0,0,.35), rgba(0,0,0,.10));
      backdrop-filter: blur(6px);
      z-index:10;
    }
    .ctrl-btn{
      appearance:none; border:0; border-radius:12px;
      padding:12px 16px; font-weight:700; font-size:15px;
      background:var(--btn); color:var(--btnText); box-shadow:0 6px 16px var(--shadow);
      cursor:pointer;
    }
    .ctrl-btn:active{ transform:translateY(1px); background:var(--btnHover); }

    #muteIcon{ margin-left:8px; font-size:12px; color:var(--muted); cursor:pointer; }

    /* Game container & canvas */
    #game-container{
      position:fixed;
      top:var(--hudH);
      bottom:var(--ctrlH);
      left:0; right:0;
      height: calc(100svh - var(--hudH) - var(--ctrlH));
    }
    #game{
      width:100%; height:100%; display:block;
      touch-action: none;
    }

    /* Overlays */
    .overlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.42);
      backdrop-filter: blur(4px);
      z-index:20;
    }
    .panel{
      width:min(92vw, 420px);
      background:var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow:0 12px 40px rgba(0,0,0,.5);
      padding:22px;
      text-align:center;
    }
    .title{ font-size:28px; font-weight:900; margin:6px 0 16px; }
    .subtitle{ color:#c8d0db; margin-bottom:18px; font-size:14px; line-height:1.4; }
    .stack{ display:flex; gap:12px; flex-wrap:wrap; justify-content:center; }
    .btn{
      appearance:none; border:0; border-radius:12px; padding:14px 16px;
      background:#334155; color:#f7fafc; font-weight:800; font-size:15px;
      cursor:pointer; box-shadow:0 6px 16px var(--shadow);
      min-width:140px;
    }
    .btn.primary{ background:#2563eb; }
    .btn.danger{ background:#be123c; }
    .btn:hover{ filter:brightness(1.05); }
    .btn:active{ transform: translateY(1px); }

    .hidden{ display:none !important; }

    /* Game Over text */
    .finalScore{ font-size:24px; font-weight:800; margin:6px 0 12px; }
    .newHigh{ color:var(--accent); font-weight:900; animation:bling 900ms ease-out both; }
    @keyframes bling { from{ filter:brightness(0.9); transform:scale(.97);} to{ filter:brightness(1.2); transform:scale(1.02);} }

    /* Red edge flash overlay (penalty) */
    #redFlash{
      pointer-events:none;
      position:fixed; inset:0; z-index:19; opacity:0;
      background: radial-gradient(circle at 50% 50%,
        rgba(255,0,0,0) 65%,
        rgba(255,0,0,0.25) 80%,
        rgba(255,0,0,0.6) 100%);
    }
    #redFlash.flash{ animation:flashEdge 320ms ease-out; }
    @keyframes flashEdge{ 0%{opacity:.0;} 30%{opacity:.7;} 100%{opacity:0;} }
  </style>
</head>
<body>
  <!-- HUD -->
  <div id="hud">
    <div id="score">Score: 1000</div>
    <div id="time">
      Time: 0:00 <span class="best-part">(Best 0:00)</span>
    </div>
    <div id="high">High: 0</div>
  </div>

  <!-- Game area -->
  <div id="game-container">
    <canvas id="game" width="300" height="150"></canvas>
  </div>

  <!-- Controls -->
  <div id="controls">
    <button id="pauseBtn" class="ctrl-btn">‚è∏ Pause</button>
    <div style="display:flex; align-items:center; gap:8px;">
      <button id="restartBtn" class="ctrl-btn">üîÑ Restart</button>
      <span id="muteIcon">üîä</span>
    </div>
  </div>

  <!-- Red flash overlay -->
  <div id="redFlash"></div>

  <!-- Start Screen -->
  <div id="startOverlay" class="overlay">
    <div class="panel">
      <div class="title">Circle Tapper</div>
      <div class="subtitle">
        Tap growing circles before they turn <b style="color:#ef4444">red</b> (&gt;80%).<br/>
        Earn more by tapping earlier ‚Äî lose points if you're late.
      </div>
      <div class="stack">
        <button id="startBtn" class="btn primary">Start Game</button>
      </div>
    </div>
  </div>

  <!-- Pause Menu -->
  <div id="pauseOverlay" class="overlay hidden">
    <div class="panel">
      <div class="title">Paused</div>
      <div class="stack" style="margin-top:8px; margin-bottom:4px;">
        <button id="resumeBtn" class="btn primary">Resume</button>
        <button id="pmRestartBtn" class="btn">Restart</button>
        <button id="muteToggleBtn" class="btn">Mute / Unmute</button>
        <button id="backToStartBtn" class="btn danger">Back to Start</button>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOverOverlay" class="overlay hidden">
    <div class="panel">
      <div class="title">Game Over</div>
      <div id="finalScore" class="finalScore">Score: 0</div>
      <div id="finalTime" class="finalScore" style="font-size:18px;">Time: 0:00</div>
      <div id="bestTime" style="color:#c8d0db; font-weight:700; margin-bottom:8px;">Best: 0:00</div>
      <div id="newHighBanner" class="newHigh hidden">üèÜ NEW HIGH SCORE!</div>
      <div class="stack" style="margin-top:8px;">
        <button id="playAgainBtn" class="btn primary">Play Again</button>
        <button id="goStartBtn" class="btn">Back to Start</button>
      </div>
    </div>
  </div>

  <script>
    /**
     * Circle Tapper ‚Äî Single-file implementation (with survival timer + gentler balance)
     * Mobile-first, works in Safari on iPhone. No external libs.
     */

    // ----- DOM refs
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const timeEl = document.getElementById('time');
    const redFlashEl = document.getElementById('redFlash');

    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    const pauseOverlay = document.getElementById('pauseOverlay');
    const resumeBtn = document.getElementById('resumeBtn');
    const pmRestartBtn = document.getElementById('pmRestartBtn');
    const backToStartBtn = document.getElementById('backToStartBtn');
    const muteToggleBtn = document.getElementById('muteToggleBtn');

    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScoreEl = document.getElementById('finalScore');
    const finalTimeEl = document.getElementById('finalTime');
    const bestTimeEl = document.getElementById('bestTime');
    const newHighBanner = document.getElementById('newHighBanner');

    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const muteIcon = document.getElementById('muteIcon');

    // ----- Safe Storage helpers
    const safeLS = {
      get(key, def = null) {
        try { const v = localStorage.getItem(key); return v === null ? def : v; }
        catch { return def; }
      },
      set(key, value) {
        try { localStorage.setItem(key, value); } catch {}
      }
    };

    // ----- Game constants (design-driven)
    const START_SCORE = 1000;

    // passive drain
    const SURVIVAL_LOSS_PER_SEC = 100;

    // Simultaneous circle spawns speed
    const SPAWN_SPEED = 1.05;

    // Difficulty scaling (time t in ms)
    function spawnIntervalMs(t){
      // 1.5s * e^(-0.0015 t) -> min 0.4s
      return Math.max(400, 1500 * Math.exp(-0.0015 * (t)));
    }
    function growthSpeedPxPerSec(t){
      // 20 + 100 * t/60000 cap 50
      return Math.min(50, 20 + 100 * (t / 60000));
    }
    function maxCirclesAllowed(t){
      // floor(1 + log_{1.5}(1 + t/10000)) <= 6
      const val = 1 + (Math.log(1 + t/10000) / Math.log(SPAWN_SPEED));
      return Math.min(10, Math.max(1, Math.floor(val)));
    }

    // Visual thresholds
    const DANGER_THRESHOLD = 0.80; // 80%
    const MIN_GROWTH = 40; // px/s
    const MAX_GROWTH = 100; // px/s

    // Tuning knobs added
    const MIN_TAP_REWARD = 100;      // floor for small-but-not-zero reward on early taps
    const HITBOX_PAD = 18;          // easier taps (was +8)
    const MIN_MAX_RADIUS = 40;
    const MAX_MAX_RADIUS = 70;

    // ----- Audio (negative feedback), created on first Start
    let audioCtx = null;
    let isMuted = false;

    function initAudio(){
      if (audioCtx || isMuted) return;
      try{
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }catch(e){ audioCtx = null; }
    }
    function buzzNegative(){
      if (!audioCtx || isMuted) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = 'square';
      osc.frequency.setValueAtTime(160, now);
      osc.frequency.exponentialRampToValueAtTime(90, now + 0.12);

      gain.gain.setValueAtTime(0.001, now);
      gain.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.14);

      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.16);
    }

    // ----- Haptics
    function vibrate(ms=60){
      if (navigator.vibrate) {
        try { navigator.vibrate(ms); } catch(_) {}
      }
    }

    // ----- Storage
    const LS_HIGH = 'circleTapper.high.v1';
    const LS_MUTED = 'circleTapper.muted.v1';
    const LS_BEST_TIME = 'circleTapper.bestTimeMs.v1';
    function loadHigh(){ return parseInt(safeLS.get(LS_HIGH, '0') || '0', 10); }
    function saveHigh(v){ safeLS.set(LS_HIGH, String(v)); }
    function loadMuted(){ return safeLS.get(LS_MUTED, '0') === '1'; }
    function saveMuted(v){ safeLS.set(LS_MUTED, v ? '1' : '0'); }
    function loadBestTimeMs(){ return parseInt(safeLS.get(LS_BEST_TIME, '0') || '0', 10); }
    function saveBestTimeMs(v){ safeLS.set(LS_BEST_TIME, String(v)); }

    // ----- Canvas sizing (retina)
    let viewW = 0, viewH = 0, dpr = Math.max(1, window.devicePixelRatio || 1);
    function resizeCanvas(){
      const rect = document.getElementById('game-container').getBoundingClientRect();
      viewW = Math.max(1, Math.floor(rect.width));
      viewH = Math.max(1, Math.floor(rect.height));
      dpr = Math.max(1, (window.devicePixelRatio || 1));
      canvas.width = Math.floor(viewW * dpr);
      canvas.height = Math.floor(viewH * dpr);
      canvas.style.width = viewW + 'px';
      canvas.style.height = viewH + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas, 50));

    // ----- Game state
    const STATE = { START:'start', PLAYING:'playing', PAUSED:'paused', GAMEOVER:'gameover' };
    let state = STATE.START;

    let score = START_SCORE;
    let sessionPeak = START_SCORE;
    let high = loadHigh();
    let bestTimeMs = loadBestTimeMs();
    let elapsedMs = 0; // advances only during PLAYING
    let lastTs = performance.now();
    let timeSinceSpawnMs = 0;

    // circles, ripples, floating texts
    const circles = [];
    const ripples = [];
    const floaters = [];

    class Circle {
      constructor(x, y, maxR, growth){
        this.x = x; this.y = y;
        // slightly larger start size to feel more tappable
        this.r = Math.max(6, Math.min(12, maxR * 0.16));
        this.maxR = maxR;
        this.growth = growth; // px/sec
        // more generous base reward (was 160*(growth/MIN_GROWTH)+160)
        this.baseReward = Math.round(160 * (this.growth / MIN_GROWTH) + 160);
        // visual pulse phase
        this.pulse = Math.random() * Math.PI * 2;
      }
      update(dt){
        this.pulse += dt * 6;
        this.r += this.growth * dt;
        if (this.r >= this.maxR){
          // auto penalty and remove (softer: 0.25x instead of 0.5x)
          applyScore(-Math.round(this.baseReward * 0.25), this.x, this.y, true);
          addFloater('Late!', this.x, this.y - 20, 'rgba(255,77,79,0.95)');
          return true; // remove
        }
        return false;
      }
      draw(ctx){
        const ratio = this.r / this.maxR;
        // color mapping
        let fill = '#ffffff';
        if (ratio < 0.4){ fill = '#ffffff'; }
        else if (ratio < DANGER_THRESHOLD){ fill = '#69a7ff'; } // blue mid
        else if (ratio <= 1.0){ fill = '#ef4444'; } // red danger
        else { fill = '#111'; }

        // subtle glow
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetY = 2;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fillStyle = fill;
        ctx.fill();

        // pulse ring (very faint)
        const ringR = this.r + 4 + Math.sin(this.pulse) * 1.5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, ringR, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.restore();
      }
    }

    function addRipple(x,y){
      ripples.push({x,y,r:8, life:0});
    }
    function drawRipples(dt){
      for (let i=ripples.length-1;i>=0;i--){
        const rp = ripples[i];
        rp.life += dt;
        rp.r += 180 * dt;
        const alpha = Math.max(0, 0.4 - rp.life * 0.6);
        ctx.beginPath();
        ctx.arc(rp.x, rp.y, rp.r, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
        ctx.lineWidth = 3;
        ctx.stroke();
        if (alpha <= 0) ripples.splice(i,1);
      }
    }

    function addFloater(text, x, y, color){
      floaters.push({text, x, y, vy:-60, life:0, color});
    }
    function drawFloaters(dt){
      for (let i=floaters.length-1;i>=0;i--){
        const f = floaters[i];
        f.life += dt;
        f.y += f.vy * dt;
        const alpha = Math.max(0, 1 - f.life*1.8);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = '700 16px ui-sans-serif, -apple-system, Roboto, Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = f.color;
        ctx.fillText(f.text, f.x, f.y);
        ctx.restore();
        if (alpha <= 0) floaters.splice(i,1);
      }
    }

    function showRedFlash(){
      redFlashEl.classList.remove('flash');
      void redFlashEl.offsetWidth;
      redFlashEl.classList.add('flash');
    }

    function applyScore(delta, x, y, isAuto=false){
      score = Math.max(0, score + delta);
      if (score > sessionPeak) sessionPeak = score;
      if (delta >= 0){
        addFloater('+'+delta, x, y-8, 'rgba(51,209,122,0.95)');
        addRipple(x,y);
      } else {
        addFloater(String(delta), x, y-8, 'rgba(255,77,79,0.95)');
        showRedFlash();
        vibrate(60);
        buzzNegative();
      }
      // live high score update
      if (score > high){
        high = score;
        saveHigh(high);
      }
      updateHud();
      if (score <= 0){
        endGame();
      }
    }

    function fmtMs(ms){
      const total = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m}:${String(s).padStart(2,'0')}`;
    }

    function updateHud(){
      scoreEl.textContent = `Score: ${Math.max(0, Math.floor(score))}`;
      highEl.textContent = `High: ${Math.floor(high)}`;
      muteIcon.textContent = isMuted ? 'üîá' : 'üîä';
      if (timeEl){
        timeEl.textContent = `Time: ${fmtMs(elapsedMs)} (Best ${fmtMs(bestTimeMs)})`;
      }
    }

    function resetGameValues(){
      score = START_SCORE;
      sessionPeak = START_SCORE;
      elapsedMs = 0;
      timeSinceSpawnMs = 0;
      circles.length = 0;
      ripples.length = 0;
      floaters.length = 0;
      updateHud();
    }

    function spawnCircle(){
      // choose max radius relative to viewport size for variety (with explicit min/max caps)
      const viewMin = Math.min(viewW, viewH);
      const minMaxR = Math.max(MIN_MAX_RADIUS, viewMin * 0.09);
      const maxMaxR = Math.max(MAX_MAX_RADIUS, viewMin * 0.16);
      const maxR = rand(minMaxR, Math.min(maxMaxR, viewMin * 0.20));

      // position within safe bounds
      const x = rand(maxR + 4, viewW - maxR - 4);
      const y = rand(maxR + 4, viewH - maxR - 4);

      // current difficulty growth speed (+/- small jitter)
      const baseGrowth = growthSpeedPxPerSec(elapsedMs);
      const growth = clamp(baseGrowth * rand(0.95, 1.08), MIN_GROWTH, MAX_GROWTH);

      circles.push(new Circle(x, y, maxR, growth));
    }

    // ----- Utility
    function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }
    function rand(a, b){ return a + Math.random()*(b-a); }
    function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

    // ----- Input (tap)
    function handleTap(px, py){
      if (state !== STATE.PLAYING) return;
      // choose topmost (last drawn) circle under finger
      for (let i = circles.length - 1; i >= 0; i--){
        const c = circles[i];
        // larger hitbox padding
        if (dist2(px, py, c.x, c.y) <= (c.r + HITBOX_PAD) * (c.r + HITBOX_PAD)){
          const ratio = c.r / c.maxR;
          if (ratio < DANGER_THRESHOLD){
            // reward decays linearly to 0 at 80%, but with a floor
            const s = ratio / DANGER_THRESHOLD; // 0..1
            const reward = Math.max(MIN_TAP_REWARD, Math.round(c.baseReward * (1 - s)));
            applyScore(reward, c.x, c.y);
          } else if (ratio <= 1.0){
            // softer penalty in red zone: 0 -> 0.35x baseReward between 80%-100%
            const over = (ratio - DANGER_THRESHOLD) / (1 - DANGER_THRESHOLD); // 0..1
            const penalty = Math.round(0.35 * c.baseReward * over);
            applyScore(-penalty, c.x, c.y);
          } else {
            // oversized fallback (shouldn't happen)
            applyScore(-c.baseReward, c.x, c.y);
          }
          circles.splice(i,1);
          return;
        }
      }
      // no penalty for empty tap
    }

    // pointer listeners (mouse + touch)
    canvas.addEventListener('pointerdown', (e)=>{
      const rect = canvas.getBoundingClientRect();
      handleTap((e.clientX - rect.left), (e.clientY - rect.top));
    }, {passive:true});

    // Pause when tab/app loses visibility
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && state === STATE.PLAYING) pauseGame();
    });

    // ----- State transitions
    function startGame(){
      initAudio(); // unlock on user gesture
      resetGameValues();
      state = STATE.PLAYING;
      startOverlay.classList.add('hidden');
      pauseOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      lastTs = performance.now();
      requestAnimationFrame(tick);
    }
    function pauseGame(){
      if (state !== STATE.PLAYING) return;
      state = STATE.PAUSED;
      pauseOverlay.classList.remove('hidden');
    }
    function resumeGame(){
      if (state !== STATE.PAUSED) return;
      state = STATE.PLAYING;
      pauseOverlay.classList.add('hidden');
      lastTs = performance.now(); // reset delta to avoid spike
      requestAnimationFrame(tick);
    }
    function endGame(){
      if (state === STATE.GAMEOVER) return;
      state = STATE.GAMEOVER;
      finalScoreEl.textContent = `Best This Run: ${Math.floor(sessionPeak)}`;

      // compute this run's survival time
      const sessionMs = elapsedMs;

      // update best time if improved
      if (sessionMs > bestTimeMs){
        bestTimeMs = sessionMs;
        saveBestTimeMs(bestTimeMs);
      }

      // fill the Game Over panel time fields
      if (finalTimeEl) finalTimeEl.textContent = `Time: ${fmtMs(sessionMs)}`;
      //if (bestTimeEl)  bestTimeEl.textContent  = `Best: ${fmtMs(bestTimeMs)}`;

      // score high banner
      if (sessionPeak >= high){
        newHighBanner.classList.remove('hidden');
      } else {
        newHighBanner.classList.add('hidden');
      }
      gameOverOverlay.classList.remove('hidden');
    }
    function backToStart(){
      state = STATE.START;
      startOverlay.classList.remove('hidden');
      pauseOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
    }
    function restartGame(){
      resetGameValues();
      state = STATE.PLAYING;
      pauseOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      lastTs = performance.now();
      requestAnimationFrame(tick);
    }

    // Buttons
    startBtn.addEventListener('click', startGame);
    pauseBtn.addEventListener('click', pauseGame);
    resumeBtn.addEventListener('click', resumeGame);
    pmRestartBtn.addEventListener('click', restartGame);
    backToStartBtn.addEventListener('click', backToStart);
    restartBtn.addEventListener('click', restartGame);
    muteToggleBtn.addEventListener('click', ()=>{ isMuted = !isMuted; saveMuted(isMuted); updateHud(); });
    muteIcon.addEventListener('click', ()=>{ isMuted = !isMuted; saveMuted(isMuted); updateHud(); });

    // ----- Main loop
    function tick(ts){
      const dt = Math.min(0.05, (ts - lastTs) / 1000); // cap delta at 50ms
      lastTs = ts;

      if (state === STATE.PLAYING){
        elapsedMs += dt * 1000;
        timeSinceSpawnMs += dt * 1000;

        // survival drain
        score -= SURVIVAL_LOSS_PER_SEC * dt;
        if (score <= 0){ score = 0; updateHud(); endGame(); return; }
        // live high score
        if (score > high){ high = score; saveHigh(high); }
        updateHud();

        // spawn logic
        const maxC = maxCirclesAllowed(elapsedMs);
        let nextInterval = spawnIntervalMs(elapsedMs);

        if (circles.length >= maxC) {
          timeSinceSpawnMs = Math.min(timeSinceSpawnMs, nextInterval);
        }

        while (timeSinceSpawnMs >= nextInterval && circles.length < maxC){
          spawnCircle();
          timeSinceSpawnMs -= nextInterval;
          nextInterval = spawnIntervalMs(elapsedMs);
        }

        // update circles
        for (let i = circles.length-1; i>=0; i--){
          if (circles[i].update(dt)){
            circles.splice(i,1);
          }
        }
      }

      // draw
      draw(dt);

      if (state === STATE.PLAYING){
        requestAnimationFrame(tick);
      }
    }

    function draw(dt){
      ctx.clearRect(0,0,viewW, viewH);

      // draw circles
      for (let i=0;i<circles.length;i++){
        circles[i].draw(ctx);
      }

      // effects
      drawRipples(dt);
      drawFloaters(dt);
    }

    // ----- Init
    function boot(){
      isMuted = loadMuted();
      high = loadHigh();
      bestTimeMs = loadBestTimeMs();
      updateHud();
      resizeCanvas();
      state = STATE.START;
      startOverlay.classList.remove('hidden');
      draw(0);
    }
    window.addEventListener('load', boot, {once:true});

    // Prevent iOS double-tap zoom on controls
    ;['startBtn','resumeBtn','pmRestartBtn','backToStartBtn','pauseBtn','restartBtn','playAgainBtn','goStartBtn','muteToggleBtn'].forEach(id=>{
      const el = document.getElementById(id);
      if (el){
        el.addEventListener('touchend', ()=>{}, {passive:true});
      }
    });

    // Game Over buttons
    document.getElementById('playAgainBtn').addEventListener('click', ()=>{
      gameOverOverlay.classList.add('hidden');
      restartGame();
    });
    document.getElementById('goStartBtn').addEventListener('click', backToStart);
  </script>
</body>
</html>
