<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Circle Rush</title>
<style>
  :root {
    --safe-top: env(safe-area-inset-top);
    --safe-bottom: env(safe-area-inset-bottom);
  }
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html, body {
    margin: 0; padding: 0; height: 100%; background: #0b0f16; color: #fff;
    font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", Inter, Arial, sans-serif;
  }
  #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; height: 100dvh; }
  .topbar, .bottombar {
    display: flex; align-items: center; justify-content: space-between;
    padding: calc(8px + var(--safe-top)) 14px 8px 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    backdrop-filter: blur(6px);
  }
  .bottombar {
    padding: 8px 14px calc(10px + var(--safe-bottom)) 14px;
  }
  .score { font-weight: 800; font-size: 20px; letter-spacing: 0.25px; }
  .high { font-weight: 700; font-size: 14px; color: #f4d65e; opacity: 0.9; }
  .btn {
    appearance: none; border: none; border-radius: 16px; padding: 10px 14px;
    font-weight: 700; font-size: 16px; color: #0b0f16; background: #ffffff; cursor: pointer;
    box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  }
  .btn.secondary { background: #dfe7ff; }
  .btn.ghost { background: rgba(255,255,255,0.16); color: #fff; }
  .btn:active { transform: translateY(1px); }
  #canvasWrap { position: relative; overflow: hidden; }
  canvas { display: block; width: 100%; height: 100%; }
  /* Overlays */
  .overlay {
    position: absolute; inset: 0; display: none; align-items: center; justify-content: center; flex-direction: column;
    background: radial-gradient(1200px 1200px at 50% 50%, rgba(0,0,0,0.35), rgba(0,0,0,0.75));
    gap: 16px; z-index: 10; text-align: center; padding: 24px;
  }
  .overlay.show { display: flex; }
  .title { font-size: 36px; font-weight: 900; letter-spacing: 0.5px; text-shadow: 0 4px 24px rgba(0,0,0,0.5); }
  .subtitle { font-size: 14px; opacity: 0.85; }
  .row { display:flex; gap:12px; flex-wrap: wrap; align-items: center; justify-content: center; }
  .gold { color: #f4d65e; font-weight: 800; }
  /* Red damage border flash */
  .damage-border {
    position: absolute; inset: 0; pointer-events: none; border: 6px solid rgba(255, 64, 64, 0);
    box-shadow: 0 0 0 0 rgba(255,64,64,0);
    z-index: 9; border-radius: 12px;
  }
  .damage-border.flash {
    animation: redflash 300ms ease-out;
  }
  @keyframes redflash {
    0% { border-color: rgba(255,64,64,0); box-shadow: 0 0 0 0 rgba(255,64,64,0); }
    30% { border-color: rgba(255,64,64,0.85); box-shadow: 0 0 30px 6px rgba(255,64,64,0.5); }
    100% { border-color: rgba(255,64,64,0); box-shadow: 0 0 0 0 rgba(255,64,64,0); }
  }
  /* Small helper badges */
  .badge { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.1); }
  .muted { opacity: 0.7; }
</style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <div class="score"><span id="scoreLabel">Score</span>: <span id="scoreVal">1000</span></div>
      <div class="high">High: <span id="highVal">0</span></div>
    </div>

    <div id="canvasWrap">
      <canvas id="game"></canvas>

      <!-- Overlays -->
      <div id="startOverlay" class="overlay show">
        <div class="title">Circle Rush</div>
        <div class="subtitle">Tap circles before they get too big. Faster-growing circles are worth more. Don‚Äôt let your score hit zero!</div>
        <div class="row muted">
          <span class="badge">Reward zone: &lt; 80%</span>
          <span class="badge">Penalty: ‚â• 80% (max ‚àí100)</span>
          <span class="badge">‚àí100 / sec survival drain</span>
        </div>
        <div class="row">
          <button id="startBtn" class="btn" aria-label="Start Game">Start</button>
        </div>
        <div class="subtitle">High Score: <span class="gold" id="startHigh">0</span></div>
      </div>

      <div id="pauseOverlay" class="overlay">
        <div class="title">Game Paused</div>
        <div class="row">
          <button id="resumeBtn" class="btn" aria-label="Resume">Resume</button>
          <button id="restartFromPauseBtn" class="btn secondary" aria-label="Restart">Restart</button>
        </div>
        <div class="row">
          <button id="muteBtn" class="btn ghost" aria-label="Mute/Unmute">üîà Sound: Off</button>
          <button id="homeBtn" class="btn ghost" aria-label="Back to Start">üè† Home</button>
        </div>
      </div>

      <div id="gameOverOverlay" class="overlay">
        <div class="title">Game Over</div>
        <div class="subtitle">Final Score: <span id="finalScore" class="gold">0</span></div>
        <div id="newHighBadge" class="subtitle" style="display:none;">üèÜ <span class="gold">NEW HIGH SCORE!</span></div>
        <div class="row">
          <button id="playAgainBtn" class="btn" aria-label="Play Again">Play Again</button>
          <button id="homeFromOverBtn" class="btn ghost" aria-label="Back to Start">üè† Home</button>
        </div>
      </div>

      <div id="damageBorder" class="damage-border"></div>
    </div>

    <div class="bottombar">
      <button id="pauseBtn" class="btn ghost" aria-label="Pause">‚è∏ Pause</button>
      <button id="restartBtn" class="btn secondary" aria-label="Restart">üîÑ Restart</button>
    </div>
  </div>

<script>
(() => {
  // ====== Config (UX-tuned) ======
  const START_SCORE = 1000;
  const SURVIVAL_DRAIN_PER_SEC = 100; // points per second
  const BASE_GROWTH = 20;   // px/sec (slowest)
  const MAX_GROWTH = 120;   // px/sec (cap)
  const MAX_CONCURRENT = 6; // cap via curve
  const MAX_RADIUS = 52;    // px at 100% (tweak for density)
  const MIN_RADIUS = 8;     // starting size (visual)
  const REWARD_THRESHOLD = 0.8; // 80%
  const MAX_PENALTY = 100;  // points

  // Difficulty curves as discussed
  function spawnIntervalMs(tMs) {
    return Math.max(400, 1500 * Math.exp(-0.0015 * tMs));
  }
  function growthSpeedPxPerSec(tMs) {
    const linear = BASE_GROWTH + (100 * tMs) / 60000; // over ~1 min
    return Math.min(MAX_GROWTH, linear);
  }
  function maxCirclesAllowed(tMs) {
    const v = 1 + Math.log(1 + tMs / 10000) / Math.log(1.5);
    return Math.min(MAX_CONCURRENT, Math.floor(1 + v));
  }

  // ====== DOM ======
  const canvas = document.getElementById('game');
  const wrap = document.getElementById('canvasWrap');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreValEl = document.getElementById('scoreVal');
  const highValEl = document.getElementById('highVal');
  const startHighEl = document.getElementById('startHigh');

  const startOverlay = document.getElementById('startOverlay');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartFromPauseBtn = document.getElementById('restartFromPauseBtn');
  const homeBtn = document.getElementById('homeBtn');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const homeFromOverBtn = document.getElementById('homeFromOverBtn');
  const muteBtn = document.getElementById('muteBtn');
  const damageBorder = document.getElementById('damageBorder');
  const finalScoreEl = document.getElementById('finalScore');
  const newHighBadge = document.getElementById('newHighBadge');

  // ====== Audio / Haptics ======
  let audioCtx = null;
  let soundEnabled = false; // muted by default

  function ensureAudio() {
    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch(e) { audioCtx = null; }
    }
  }
  function playBeep(freq = 140, durationMs = 120) {
    if (!soundEnabled || !audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.08, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + durationMs/1000);
    o.connect(g).connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + durationMs/1000 + 0.02);
  }
  function vibrate(ms=80) {
    if (navigator.vibrate) { try { navigator.vibrate(ms); } catch(e){} }
  }
  function lossFeedback() {
    vibrate(100);
    playBeep(160, 140);
    // Red border flash
    damageBorder.classList.remove('flash');
    // force reflow
    void damageBorder.offsetWidth;
    damageBorder.classList.add('flash');
  }

  muteBtn.addEventListener('click', () => {
    ensureAudio();
    soundEnabled = !soundEnabled;
    muteBtn.textContent = soundEnabled ? 'üîä Sound: On' : 'üîà Sound: Off';
  });

  // ====== Canvas sizing ======
  function resize() {
    const rect = wrap.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // ====== Game State ======
  const circles = [];
  const ripples = []; // tap ripple effects
  const floaters = []; // floating +/- points

  let running = false;
  let paused = false;
  let inStart = true;
  let inGameOver = false;

  let startTime = 0;
  let elapsedMs = 0;

  let lastFrameTs = 0;
  let lastSpawnMs = 0;

  let score = START_SCORE;
  let displayScore = START_SCORE;

  const highKey = 'circle_rush_highscore_v1';
  let highScore = Number(localStorage.getItem(highKey) || 0);
  highValEl.textContent = String(highScore);
  startHighEl.textContent = String(highScore);

  function resetGame() {
    circles.length = 0;
    ripples.length = 0;
    floaters.length = 0;
    score = START_SCORE;
    displayScore = START_SCORE;
    elapsedMs = 0;
    lastSpawnMs = 0;
    lastFrameTs = 0;
    running = true;
    paused = false;
    inGameOver = false;
    updateScoreUI(true);
  }

  // ====== Circle Helpers ======
  function spawnCircle() {
    const rect = wrap.getBoundingClientRect();
    // Avoid UI bars by using wrap area; we already use full area excluding bars via grid
    const maxR = MAX_RADIUS;
    const x = Math.random() * rect.width;
    const y = Math.random() * rect.height;
    const createdAt = performance.now();
    const speed = growthSpeedPxPerSec(elapsedMs); // px/sec
    circles.push({
      x, y,
      r: MIN_RADIUS,
      maxR,
      createdAt,
      speed,
      removed: false,
    });
  }

  function circleColorByRatio(ratio) {
    // 0-0.4 white -> 0.4-0.8 blue -> 0.8-1 red -> >=1 black
    if (ratio >= 1) return 'black';
    if (ratio >= REWARD_THRESHOLD) return '#ff3b3b';
    if (ratio >= 0.4) return '#4da3ff';
    return '#ffffff';
  }

  function scoreOnTap(circle) {
    const ratio = Math.min(1, circle.r / circle.maxR);
    if (ratio < REWARD_THRESHOLD) {
      const baseReward = 1000 * (1 - ratio) / REWARD_THRESHOLD; // at ratio=0 -> 1000
      const growthMult = circle.speed / BASE_GROWTH;
      return Math.max(1, Math.round(baseReward * growthMult));
    } else {
      // penalty scales linearly from -1 at 0.8 to -100 at 1.0
      const t = (ratio - REWARD_THRESHOLD) / (1 - REWARD_THRESHOLD); // 0..1
      const penalty = Math.round(1 + t * (MAX_PENALTY - 1));
      return -penalty;
    }
  }

  function scoreOnMiss() {
    return -MAX_PENALTY; // full -100 when a circle reaches max size un-tapped
  }

  // ====== Input (touch + mouse) ======
  function getLocalPoint(evt) {
    const rect = wrap.getBoundingClientRect();
    let x=0, y=0;
    if (evt.touches && evt.touches.length) {
      x = evt.touches[0].clientX - rect.left;
      y = evt.touches[0].clientY - rect.top;
    } else {
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
    }
    return { x, y };
  }

  function onTap(evt) {
    ensureAudio(); // iOS requires user gesture to unlock
    if (!running || paused || inStart || inGameOver) return;
    evt.preventDefault();
    const { x, y } = getLocalPoint(evt);

    // Check circles from topmost (last drawn)
    let hit = -1;
    for (let i = circles.length - 1; i >= 0; i--) {
      const c = circles[i];
      if (c.removed) continue;
      const dx = x - c.x, dy = y - c.y;
      if (dx*dx + dy*dy <= c.r*c.r) { hit = i; break; }
    }
    // Ripple effect at tap
    ripples.push({ x, y, r: 0, alpha: 0.5 });

    if (hit >= 0) {
      const c = circles[hit];
      const delta = scoreOnTap(c);
      score = Math.max(0, score + delta);
      floaters.push({ x: c.x, y: c.y, text: (delta>0?'+':'') + delta, life: 700, color: delta>0 ? '#65f58f' : '#ff6b6b' });
      if (delta < 0) lossFeedback();

      c.removed = true; // mark for removal
    }
  }

  canvas.addEventListener('touchstart', onTap, { passive: false });
  canvas.addEventListener('mousedown', onTap);

  // Prevent scroll bounce on iOS while playing
  document.addEventListener('touchmove', (e) => {
    if (running && !inStart && !inGameOver && !paused) e.preventDefault();
  }, { passive: false });

  // ====== UI Actions ======
  startBtn.addEventListener('click', () => {
    inStart = false;
    startOverlay.classList.remove('show');
    resetGame();
    startTime = performance.now();
    requestAnimationFrame(loop);
  });

  pauseBtn.addEventListener('click', () => {
    if (!running || inStart || inGameOver) return;
    paused = true;
    pauseOverlay.classList.add('show');
  });

  resumeBtn.addEventListener('click', () => {
    if (!running) return;
    paused = false;
    lastFrameTs = performance.now();
    pauseOverlay.classList.remove('show');
    requestAnimationFrame(loop);
  });

  restartBtn.addEventListener('click', () => {
    if (inStart) return;
    startOverlay.classList.remove('show');
    pauseOverlay.classList.remove('show');
    gameOverOverlay.classList.remove('show');
    inGameOver = false;
    resetGame();
    startTime = performance.now();
    requestAnimationFrame(loop);
  });

  restartFromPauseBtn.addEventListener('click', () => {
    pauseOverlay.classList.remove('show');
    inGameOver = false;
    resetGame();
    startTime = performance.now();
    requestAnimationFrame(loop);
  });

  homeBtn.addEventListener('click', () => {
    // Back to start without changing high score
    running = false; paused = false; inGameOver = false; inStart = true;
    startHighEl.textContent = String(highScore);
    startOverlay.classList.add('show');
    pauseOverlay.classList.remove('show');
    gameOverOverlay.classList.remove('show');
  });

  playAgainBtn.addEventListener('click', () => {
    gameOverOverlay.classList.remove('show');
    inGameOver = false; inStart = false;
    resetGame();
    startTime = performance.now();
    requestAnimationFrame(loop);
  });

  homeFromOverBtn.addEventListener('click', () => {
    running = false; paused = false; inGameOver = false; inStart = true;
    startHighEl.textContent = String(highScore);
    startOverlay.classList.add('show');
    gameOverOverlay.classList.remove('show');
  });

  // ====== Rendering helpers ======
  function drawBackground(t) {
    // subtle animated gradient by time/difficulty
    const g = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    const darkShift = Math.min(0.35, elapsedMs / 120000); // darker over 2 min
    g.addColorStop(0, `rgba(10,14,22,1)`);
    g.addColorStop(1, `rgba(${10+Math.floor(darkShift*30)},${14+Math.floor(darkShift*20)},${22+Math.floor(darkShift*10)},1)`);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function drawCircle(c) {
    const ratio = Math.min(1.05, c.r / c.maxR);
    const col = circleColorByRatio(ratio);
    ctx.save();
    // glow
    ctx.shadowColor = (ratio >= REWARD_THRESHOLD && ratio < 1) ? 'rgba(255,59,59,0.35)' :
                      (ratio >= 0.4 ? 'rgba(77,163,255,0.35)' : 'rgba(255,255,255,0.35)');
    ctx.shadowBlur = 16;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.closePath();
    ctx.fillStyle = col;
    ctx.fill();
    ctx.restore();
  }

  function drawRipple(r) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(255,255,255,${r.alpha})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }

  function drawFloater(f) {
    ctx.save();
    ctx.font = '700 16px -apple-system, Inter, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = f.color;
    ctx.globalAlpha = Math.max(0, f.life / 700);
    ctx.fillText(f.text, f.x, f.y);
    ctx.restore();
  }

  function updateScoreUI(force=false) {
    if (force) {
      scoreValEl.textContent = String(Math.round(score));
      return;
    }
    // Smooth score animation toward actual score
    const diff = score - displayScore;
    const step = Math.sign(diff) * Math.max(1, Math.floor(Math.abs(diff) * 0.12));
    if (diff !== 0) displayScore += step;
    scoreValEl.textContent = String(displayScore);
  }

  // ====== Main Loop ======
  function loop(ts) {
    if (!running) return;
    if (paused) return;

    if (!lastFrameTs) lastFrameTs = ts;
    const dt = Math.min(50, ts - lastFrameTs); // clamp to avoid big jumps
    lastFrameTs = ts;

    elapsedMs += dt;

    // Survival drain
    score = Math.max(0, score - (SURVIVAL_DRAIN_PER_SEC * dt / 1000));

    // Spawn logic
    lastSpawnMs += dt;
    const neededInterval = spawnIntervalMs(elapsedMs);
    const allow = maxCirclesAllowed(elapsedMs);
    if (circles.filter(c => !c.removed).length < allow && lastSpawnMs >= neededInterval) {
      spawnCircle();
      lastSpawnMs = 0;
    }

    // Update circles
    for (const c of circles) {
      if (c.removed) continue;
      c.r += c.speed * (dt / 1000);
      if (c.r >= c.maxR) {
        // miss penalty
        const delta = scoreOnMiss();
        score = Math.max(0, score + delta);
        floaters.push({ x: c.x, y: c.y, text: String(delta), life: 700, color: '#ff6b6b' });
        lossFeedback();
        c.removed = true;
      }
    }

    // Clean removed circles
    for (let i = circles.length - 1; i >= 0; i--) {
      if (circles[i].removed) circles.splice(i, 1);
    }

    // Update ripples
    for (let i = ripples.length - 1; i >= 0; i--) {
      const r = ripples[i];
      r.r += 240 * (dt / 1000);
      r.alpha -= 1.3 * (dt / 1000);
      if (r.alpha <= 0) ripples.splice(i, 1);
    }

    // Update floaters
    for (let i = floaters.length - 1; i >= 0; i--) {
      const f = floaters[i];
      f.y -= 28 * (dt / 1000);
      f.life -= dt;
      if (f.life <= 0) floaters.splice(i, 1);
    }

    // Render
    drawBackground(ts);
    for (const c of circles) drawCircle(c);
    for (const r of ripples) drawRipple(r);
    for (const f of floaters) drawFloater(f);

    // Score UI
    updateScoreUI(false);

    // High score live update
    if (score > highScore) {
      highScore = Math.round(score);
      localStorage.setItem(highKey, String(highScore));
      highValEl.textContent = String(highScore);
    }

    // End condition
    if (score <= 0) {
      running = false;
      inGameOver = true;
      finalScoreEl.textContent = String(Math.round(displayScore));
      const newHigh = Math.round(displayScore) >= highScore;
      newHighBadge.style.display = newHigh ? '' : 'none';
      gameOverOverlay.classList.add('show');
      return;
    }

    requestAnimationFrame(loop);
  }

  // ====== Keyboard helpers (desktop testing) ======
  window.addEventListener('keydown', (e) => {
    if (e.key === 'p') { pauseBtn.click(); }
    if (e.key === 'r') { restartBtn.click(); }
  });
})();
</script>
</body>
</html>
